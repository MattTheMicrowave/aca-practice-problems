var flatten = require('array-flatten');  // brings in the function to 'unnest'
// nested arrays

// ok look the moral is the story is you want to converge any number of
// value 1 or greater that gets passed in to this function down to zero,
// but the catch is you can only do so by splitting it into 3 one round at a
// time, then each number left that is greater than zero gets converged
// down to zero by splitting into 3 reiteratively until only zeros remain.
// because we can only split 3 at a time, this limits us in the sense
// that more than one round of splitting, ie a number 2 or greater is
// passed into the function, leads to a returned array that is nested, but
// we need to know the number total indices for each and every array that
// was generated by the function since, once all of these have been reduced
// to only zeros by splitting the number into 3 each iteration, the total number
// of indices in all of the arrays correlates to the total number of coins you
// end up with (each 0 represents one coin). therefore, we run a function that
// checks if the argument is 0, if it is, the result of that function is 1 coin,
// if it is not we split it into 3 and run the function on each result, to
// check if each result is 0 or if it as well has to be split into 3 atleast
// once to create zeros, once all zeros have been converged to, the function
// breaks, and if we can count the number of indicies of each array, we know
// the number of coins, because we can flatten a nested array this allows us
// to create one larger array containing the values (in this case all zeros or
// else the function would not have stopped) of all the indicies in all of the
// arrays generated, therefore this allows us to take the length of this array
// and set this equal to the number of coins generated/
// *** it is crucial to note that without the Math.floor() method, this
// function would run in an inifinite loop since 0 would be asymptotically
// approached but never actually attained, as the limit of 1/x as x gets larger
// and larger is 0, but it never IS zero***

function wonkyCoins(n) {
    if (n < 1) {
      return exchange(n);
    } // this checks from the get go if the argument rounded down
    // is 0 and if it is then we get 1 coin
    var outPutArray = exchange(n); // this array is set to the output array
    // of the exchange function
    var numberOfCoins = outPutArray.length; // this retrieves the length
    // of the flattened out put Array from the exchange ie the number of coins
    return numberOfCoins; // this returns the number of coins
}

function exchange(n) {
    var x = Math.floor(n); // this rounds down the original argument
    if (x == 0) {
      return 1; // if the original argument rounded down is 0 then the
      // the function returns 1 coin, this is the linchpin of the function
      // as this is required to stop the loop once 0 is reached
    }
    else {
      var coinArray = [exchange(x/2), exchange(x/3), exchange(x/4)];
      // this calls the function on each index value of the original array
      // after the original number had been split into 3, calling the function
      // on each index will converge each index to zero, by splitting the
      // index value into 3 each time until zero values are reached
      coinArray = flatten(coinArray);
      // however due to the reiterative nature of the function zeros may
      // be reached only with nested arrays, this line creates one big array
      // containing the value of each index of each array, which allows for
      // a length count that correlates to the number of coins ie the number of
      // zeros that have been generated.
      return coinArray;
    }
}



module.exports = wonkyCoins;
